// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control.proto

#ifndef PROTOBUF_INCLUDED_control_2eproto
#define PROTOBUF_INCLUDED_control_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_control_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_control_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_control_2eproto();
class ProtobufControl;
class ProtobufControlDefaultTypeInternal;
extern ProtobufControlDefaultTypeInternal _ProtobufControl_default_instance_;
class ProtobufControl_Light;
class ProtobufControl_LightDefaultTypeInternal;
extern ProtobufControl_LightDefaultTypeInternal _ProtobufControl_Light_default_instance_;
class ProtobufControl_Motors;
class ProtobufControl_MotorsDefaultTypeInternal;
extern ProtobufControl_MotorsDefaultTypeInternal _ProtobufControl_Motors_default_instance_;
class ProtobufControl_Servos;
class ProtobufControl_ServosDefaultTypeInternal;
extern ProtobufControl_ServosDefaultTypeInternal _ProtobufControl_Servos_default_instance_;
class ProtobufControl_System;
class ProtobufControl_SystemDefaultTypeInternal;
extern ProtobufControl_SystemDefaultTypeInternal _ProtobufControl_System_default_instance_;
class ProtobufControl_Vibro;
class ProtobufControl_VibroDefaultTypeInternal;
extern ProtobufControl_VibroDefaultTypeInternal _ProtobufControl_Vibro_default_instance_;
namespace google {
namespace protobuf {
template<> ::ProtobufControl* Arena::CreateMaybeMessage<::ProtobufControl>(Arena*);
template<> ::ProtobufControl_Light* Arena::CreateMaybeMessage<::ProtobufControl_Light>(Arena*);
template<> ::ProtobufControl_Motors* Arena::CreateMaybeMessage<::ProtobufControl_Motors>(Arena*);
template<> ::ProtobufControl_Servos* Arena::CreateMaybeMessage<::ProtobufControl_Servos>(Arena*);
template<> ::ProtobufControl_System* Arena::CreateMaybeMessage<::ProtobufControl_System>(Arena*);
template<> ::ProtobufControl_Vibro* Arena::CreateMaybeMessage<::ProtobufControl_Vibro>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class ProtobufControl_Servos final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufControl.Servos) */ {
 public:
  ProtobufControl_Servos();
  virtual ~ProtobufControl_Servos();

  ProtobufControl_Servos(const ProtobufControl_Servos& from);

  inline ProtobufControl_Servos& operator=(const ProtobufControl_Servos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufControl_Servos(ProtobufControl_Servos&& from) noexcept
    : ProtobufControl_Servos() {
    *this = ::std::move(from);
  }

  inline ProtobufControl_Servos& operator=(ProtobufControl_Servos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtobufControl_Servos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufControl_Servos* internal_default_instance() {
    return reinterpret_cast<const ProtobufControl_Servos*>(
               &_ProtobufControl_Servos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ProtobufControl_Servos* other);
  friend void swap(ProtobufControl_Servos& a, ProtobufControl_Servos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufControl_Servos* New() const final {
    return CreateMaybeMessage<ProtobufControl_Servos>(nullptr);
  }

  ProtobufControl_Servos* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufControl_Servos>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufControl_Servos& from);
  void MergeFrom(const ProtobufControl_Servos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufControl_Servos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 xAngle = 1;
  void clear_xangle();
  static const int kXAngleFieldNumber = 1;
  ::google::protobuf::int32 xangle() const;
  void set_xangle(::google::protobuf::int32 value);

  // int32 yAngle = 2;
  void clear_yangle();
  static const int kYAngleFieldNumber = 2;
  ::google::protobuf::int32 yangle() const;
  void set_yangle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtobufControl.Servos)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 xangle_;
  ::google::protobuf::int32 yangle_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class ProtobufControl_Motors final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufControl.Motors) */ {
 public:
  ProtobufControl_Motors();
  virtual ~ProtobufControl_Motors();

  ProtobufControl_Motors(const ProtobufControl_Motors& from);

  inline ProtobufControl_Motors& operator=(const ProtobufControl_Motors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufControl_Motors(ProtobufControl_Motors&& from) noexcept
    : ProtobufControl_Motors() {
    *this = ::std::move(from);
  }

  inline ProtobufControl_Motors& operator=(ProtobufControl_Motors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtobufControl_Motors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufControl_Motors* internal_default_instance() {
    return reinterpret_cast<const ProtobufControl_Motors*>(
               &_ProtobufControl_Motors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ProtobufControl_Motors* other);
  friend void swap(ProtobufControl_Motors& a, ProtobufControl_Motors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufControl_Motors* New() const final {
    return CreateMaybeMessage<ProtobufControl_Motors>(nullptr);
  }

  ProtobufControl_Motors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufControl_Motors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufControl_Motors& from);
  void MergeFrom(const ProtobufControl_Motors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufControl_Motors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 lPower = 1;
  void clear_lpower();
  static const int kLPowerFieldNumber = 1;
  ::google::protobuf::int32 lpower() const;
  void set_lpower(::google::protobuf::int32 value);

  // int32 lTime = 2;
  void clear_ltime();
  static const int kLTimeFieldNumber = 2;
  ::google::protobuf::int32 ltime() const;
  void set_ltime(::google::protobuf::int32 value);

  // int32 rPower = 3;
  void clear_rpower();
  static const int kRPowerFieldNumber = 3;
  ::google::protobuf::int32 rpower() const;
  void set_rpower(::google::protobuf::int32 value);

  // int32 rTime = 4;
  void clear_rtime();
  static const int kRTimeFieldNumber = 4;
  ::google::protobuf::int32 rtime() const;
  void set_rtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtobufControl.Motors)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 lpower_;
  ::google::protobuf::int32 ltime_;
  ::google::protobuf::int32 rpower_;
  ::google::protobuf::int32 rtime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class ProtobufControl_Light final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufControl.Light) */ {
 public:
  ProtobufControl_Light();
  virtual ~ProtobufControl_Light();

  ProtobufControl_Light(const ProtobufControl_Light& from);

  inline ProtobufControl_Light& operator=(const ProtobufControl_Light& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufControl_Light(ProtobufControl_Light&& from) noexcept
    : ProtobufControl_Light() {
    *this = ::std::move(from);
  }

  inline ProtobufControl_Light& operator=(ProtobufControl_Light&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtobufControl_Light& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufControl_Light* internal_default_instance() {
    return reinterpret_cast<const ProtobufControl_Light*>(
               &_ProtobufControl_Light_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProtobufControl_Light* other);
  friend void swap(ProtobufControl_Light& a, ProtobufControl_Light& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufControl_Light* New() const final {
    return CreateMaybeMessage<ProtobufControl_Light>(nullptr);
  }

  ProtobufControl_Light* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufControl_Light>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufControl_Light& from);
  void MergeFrom(const ProtobufControl_Light& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufControl_Light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 ledPower = 1;
  void clear_ledpower();
  static const int kLedPowerFieldNumber = 1;
  ::google::protobuf::int32 ledpower() const;
  void set_ledpower(::google::protobuf::int32 value);

  // bool xenonEnable = 2;
  void clear_xenonenable();
  static const int kXenonEnableFieldNumber = 2;
  bool xenonenable() const;
  void set_xenonenable(bool value);

  // @@protoc_insertion_point(class_scope:ProtobufControl.Light)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ledpower_;
  bool xenonenable_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class ProtobufControl_Vibro final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufControl.Vibro) */ {
 public:
  ProtobufControl_Vibro();
  virtual ~ProtobufControl_Vibro();

  ProtobufControl_Vibro(const ProtobufControl_Vibro& from);

  inline ProtobufControl_Vibro& operator=(const ProtobufControl_Vibro& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufControl_Vibro(ProtobufControl_Vibro&& from) noexcept
    : ProtobufControl_Vibro() {
    *this = ::std::move(from);
  }

  inline ProtobufControl_Vibro& operator=(ProtobufControl_Vibro&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtobufControl_Vibro& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufControl_Vibro* internal_default_instance() {
    return reinterpret_cast<const ProtobufControl_Vibro*>(
               &_ProtobufControl_Vibro_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProtobufControl_Vibro* other);
  friend void swap(ProtobufControl_Vibro& a, ProtobufControl_Vibro& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufControl_Vibro* New() const final {
    return CreateMaybeMessage<ProtobufControl_Vibro>(nullptr);
  }

  ProtobufControl_Vibro* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufControl_Vibro>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufControl_Vibro& from);
  void MergeFrom(const ProtobufControl_Vibro& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufControl_Vibro* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 Power = 1;
  void clear_power();
  static const int kPowerFieldNumber = 1;
  ::google::protobuf::int32 power() const;
  void set_power(::google::protobuf::int32 value);

  // int32 Time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtobufControl.Vibro)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class ProtobufControl_System final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufControl.System) */ {
 public:
  ProtobufControl_System();
  virtual ~ProtobufControl_System();

  ProtobufControl_System(const ProtobufControl_System& from);

  inline ProtobufControl_System& operator=(const ProtobufControl_System& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufControl_System(ProtobufControl_System&& from) noexcept
    : ProtobufControl_System() {
    *this = ::std::move(from);
  }

  inline ProtobufControl_System& operator=(ProtobufControl_System&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtobufControl_System& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufControl_System* internal_default_instance() {
    return reinterpret_cast<const ProtobufControl_System*>(
               &_ProtobufControl_System_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProtobufControl_System* other);
  friend void swap(ProtobufControl_System& a, ProtobufControl_System& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufControl_System* New() const final {
    return CreateMaybeMessage<ProtobufControl_System>(nullptr);
  }

  ProtobufControl_System* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufControl_System>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufControl_System& from);
  void MergeFrom(const ProtobufControl_System& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufControl_System* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool haltFlag = 1;
  void clear_haltflag();
  static const int kHaltFlagFieldNumber = 1;
  bool haltflag() const;
  void set_haltflag(bool value);

  // bool restartFlag = 2;
  void clear_restartflag();
  static const int kRestartFlagFieldNumber = 2;
  bool restartflag() const;
  void set_restartflag(bool value);

  // @@protoc_insertion_point(class_scope:ProtobufControl.System)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool haltflag_;
  bool restartflag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class ProtobufControl final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufControl) */ {
 public:
  ProtobufControl();
  virtual ~ProtobufControl();

  ProtobufControl(const ProtobufControl& from);

  inline ProtobufControl& operator=(const ProtobufControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufControl(ProtobufControl&& from) noexcept
    : ProtobufControl() {
    *this = ::std::move(from);
  }

  inline ProtobufControl& operator=(ProtobufControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtobufControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufControl* internal_default_instance() {
    return reinterpret_cast<const ProtobufControl*>(
               &_ProtobufControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ProtobufControl* other);
  friend void swap(ProtobufControl& a, ProtobufControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufControl* New() const final {
    return CreateMaybeMessage<ProtobufControl>(nullptr);
  }

  ProtobufControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufControl& from);
  void MergeFrom(const ProtobufControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProtobufControl_Servos Servos;
  typedef ProtobufControl_Motors Motors;
  typedef ProtobufControl_Light Light;
  typedef ProtobufControl_Vibro Vibro;
  typedef ProtobufControl_System System;

  // accessors -------------------------------------------------------

  // .ProtobufControl.Servos servos = 1;
  bool has_servos() const;
  void clear_servos();
  static const int kServosFieldNumber = 1;
  const ::ProtobufControl_Servos& servos() const;
  ::ProtobufControl_Servos* release_servos();
  ::ProtobufControl_Servos* mutable_servos();
  void set_allocated_servos(::ProtobufControl_Servos* servos);

  // .ProtobufControl.Motors motors = 2;
  bool has_motors() const;
  void clear_motors();
  static const int kMotorsFieldNumber = 2;
  const ::ProtobufControl_Motors& motors() const;
  ::ProtobufControl_Motors* release_motors();
  ::ProtobufControl_Motors* mutable_motors();
  void set_allocated_motors(::ProtobufControl_Motors* motors);

  // .ProtobufControl.Light light = 3;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 3;
  const ::ProtobufControl_Light& light() const;
  ::ProtobufControl_Light* release_light();
  ::ProtobufControl_Light* mutable_light();
  void set_allocated_light(::ProtobufControl_Light* light);

  // .ProtobufControl.Vibro vibro = 4;
  bool has_vibro() const;
  void clear_vibro();
  static const int kVibroFieldNumber = 4;
  const ::ProtobufControl_Vibro& vibro() const;
  ::ProtobufControl_Vibro* release_vibro();
  ::ProtobufControl_Vibro* mutable_vibro();
  void set_allocated_vibro(::ProtobufControl_Vibro* vibro);

  // .ProtobufControl.System system = 5;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 5;
  const ::ProtobufControl_System& system() const;
  ::ProtobufControl_System* release_system();
  ::ProtobufControl_System* mutable_system();
  void set_allocated_system(::ProtobufControl_System* system);

  // @@protoc_insertion_point(class_scope:ProtobufControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ProtobufControl_Servos* servos_;
  ::ProtobufControl_Motors* motors_;
  ::ProtobufControl_Light* light_;
  ::ProtobufControl_Vibro* vibro_;
  ::ProtobufControl_System* system_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtobufControl_Servos

// int32 xAngle = 1;
inline void ProtobufControl_Servos::clear_xangle() {
  xangle_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Servos::xangle() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Servos.xAngle)
  return xangle_;
}
inline void ProtobufControl_Servos::set_xangle(::google::protobuf::int32 value) {
  
  xangle_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Servos.xAngle)
}

// int32 yAngle = 2;
inline void ProtobufControl_Servos::clear_yangle() {
  yangle_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Servos::yangle() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Servos.yAngle)
  return yangle_;
}
inline void ProtobufControl_Servos::set_yangle(::google::protobuf::int32 value) {
  
  yangle_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Servos.yAngle)
}

// -------------------------------------------------------------------

// ProtobufControl_Motors

// int32 lPower = 1;
inline void ProtobufControl_Motors::clear_lpower() {
  lpower_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Motors::lpower() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Motors.lPower)
  return lpower_;
}
inline void ProtobufControl_Motors::set_lpower(::google::protobuf::int32 value) {
  
  lpower_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Motors.lPower)
}

// int32 lTime = 2;
inline void ProtobufControl_Motors::clear_ltime() {
  ltime_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Motors::ltime() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Motors.lTime)
  return ltime_;
}
inline void ProtobufControl_Motors::set_ltime(::google::protobuf::int32 value) {
  
  ltime_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Motors.lTime)
}

// int32 rPower = 3;
inline void ProtobufControl_Motors::clear_rpower() {
  rpower_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Motors::rpower() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Motors.rPower)
  return rpower_;
}
inline void ProtobufControl_Motors::set_rpower(::google::protobuf::int32 value) {
  
  rpower_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Motors.rPower)
}

// int32 rTime = 4;
inline void ProtobufControl_Motors::clear_rtime() {
  rtime_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Motors::rtime() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Motors.rTime)
  return rtime_;
}
inline void ProtobufControl_Motors::set_rtime(::google::protobuf::int32 value) {
  
  rtime_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Motors.rTime)
}

// -------------------------------------------------------------------

// ProtobufControl_Light

// int32 ledPower = 1;
inline void ProtobufControl_Light::clear_ledpower() {
  ledpower_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Light::ledpower() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Light.ledPower)
  return ledpower_;
}
inline void ProtobufControl_Light::set_ledpower(::google::protobuf::int32 value) {
  
  ledpower_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Light.ledPower)
}

// bool xenonEnable = 2;
inline void ProtobufControl_Light::clear_xenonenable() {
  xenonenable_ = false;
}
inline bool ProtobufControl_Light::xenonenable() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Light.xenonEnable)
  return xenonenable_;
}
inline void ProtobufControl_Light::set_xenonenable(bool value) {
  
  xenonenable_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Light.xenonEnable)
}

// -------------------------------------------------------------------

// ProtobufControl_Vibro

// int32 Power = 1;
inline void ProtobufControl_Vibro::clear_power() {
  power_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Vibro::power() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Vibro.Power)
  return power_;
}
inline void ProtobufControl_Vibro::set_power(::google::protobuf::int32 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Vibro.Power)
}

// int32 Time = 2;
inline void ProtobufControl_Vibro::clear_time() {
  time_ = 0;
}
inline ::google::protobuf::int32 ProtobufControl_Vibro::time() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.Vibro.Time)
  return time_;
}
inline void ProtobufControl_Vibro::set_time(::google::protobuf::int32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.Vibro.Time)
}

// -------------------------------------------------------------------

// ProtobufControl_System

// bool haltFlag = 1;
inline void ProtobufControl_System::clear_haltflag() {
  haltflag_ = false;
}
inline bool ProtobufControl_System::haltflag() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.System.haltFlag)
  return haltflag_;
}
inline void ProtobufControl_System::set_haltflag(bool value) {
  
  haltflag_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.System.haltFlag)
}

// bool restartFlag = 2;
inline void ProtobufControl_System::clear_restartflag() {
  restartflag_ = false;
}
inline bool ProtobufControl_System::restartflag() const {
  // @@protoc_insertion_point(field_get:ProtobufControl.System.restartFlag)
  return restartflag_;
}
inline void ProtobufControl_System::set_restartflag(bool value) {
  
  restartflag_ = value;
  // @@protoc_insertion_point(field_set:ProtobufControl.System.restartFlag)
}

// -------------------------------------------------------------------

// ProtobufControl

// .ProtobufControl.Servos servos = 1;
inline bool ProtobufControl::has_servos() const {
  return this != internal_default_instance() && servos_ != nullptr;
}
inline void ProtobufControl::clear_servos() {
  if (GetArenaNoVirtual() == nullptr && servos_ != nullptr) {
    delete servos_;
  }
  servos_ = nullptr;
}
inline const ::ProtobufControl_Servos& ProtobufControl::servos() const {
  const ::ProtobufControl_Servos* p = servos_;
  // @@protoc_insertion_point(field_get:ProtobufControl.servos)
  return p != nullptr ? *p : *reinterpret_cast<const ::ProtobufControl_Servos*>(
      &::_ProtobufControl_Servos_default_instance_);
}
inline ::ProtobufControl_Servos* ProtobufControl::release_servos() {
  // @@protoc_insertion_point(field_release:ProtobufControl.servos)
  
  ::ProtobufControl_Servos* temp = servos_;
  servos_ = nullptr;
  return temp;
}
inline ::ProtobufControl_Servos* ProtobufControl::mutable_servos() {
  
  if (servos_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtobufControl_Servos>(GetArenaNoVirtual());
    servos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufControl.servos)
  return servos_;
}
inline void ProtobufControl::set_allocated_servos(::ProtobufControl_Servos* servos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete servos_;
  }
  if (servos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      servos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, servos, submessage_arena);
    }
    
  } else {
    
  }
  servos_ = servos;
  // @@protoc_insertion_point(field_set_allocated:ProtobufControl.servos)
}

// .ProtobufControl.Motors motors = 2;
inline bool ProtobufControl::has_motors() const {
  return this != internal_default_instance() && motors_ != nullptr;
}
inline void ProtobufControl::clear_motors() {
  if (GetArenaNoVirtual() == nullptr && motors_ != nullptr) {
    delete motors_;
  }
  motors_ = nullptr;
}
inline const ::ProtobufControl_Motors& ProtobufControl::motors() const {
  const ::ProtobufControl_Motors* p = motors_;
  // @@protoc_insertion_point(field_get:ProtobufControl.motors)
  return p != nullptr ? *p : *reinterpret_cast<const ::ProtobufControl_Motors*>(
      &::_ProtobufControl_Motors_default_instance_);
}
inline ::ProtobufControl_Motors* ProtobufControl::release_motors() {
  // @@protoc_insertion_point(field_release:ProtobufControl.motors)
  
  ::ProtobufControl_Motors* temp = motors_;
  motors_ = nullptr;
  return temp;
}
inline ::ProtobufControl_Motors* ProtobufControl::mutable_motors() {
  
  if (motors_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtobufControl_Motors>(GetArenaNoVirtual());
    motors_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufControl.motors)
  return motors_;
}
inline void ProtobufControl::set_allocated_motors(::ProtobufControl_Motors* motors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete motors_;
  }
  if (motors) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      motors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motors, submessage_arena);
    }
    
  } else {
    
  }
  motors_ = motors;
  // @@protoc_insertion_point(field_set_allocated:ProtobufControl.motors)
}

// .ProtobufControl.Light light = 3;
inline bool ProtobufControl::has_light() const {
  return this != internal_default_instance() && light_ != nullptr;
}
inline void ProtobufControl::clear_light() {
  if (GetArenaNoVirtual() == nullptr && light_ != nullptr) {
    delete light_;
  }
  light_ = nullptr;
}
inline const ::ProtobufControl_Light& ProtobufControl::light() const {
  const ::ProtobufControl_Light* p = light_;
  // @@protoc_insertion_point(field_get:ProtobufControl.light)
  return p != nullptr ? *p : *reinterpret_cast<const ::ProtobufControl_Light*>(
      &::_ProtobufControl_Light_default_instance_);
}
inline ::ProtobufControl_Light* ProtobufControl::release_light() {
  // @@protoc_insertion_point(field_release:ProtobufControl.light)
  
  ::ProtobufControl_Light* temp = light_;
  light_ = nullptr;
  return temp;
}
inline ::ProtobufControl_Light* ProtobufControl::mutable_light() {
  
  if (light_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtobufControl_Light>(GetArenaNoVirtual());
    light_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufControl.light)
  return light_;
}
inline void ProtobufControl::set_allocated_light(::ProtobufControl_Light* light) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete light_;
  }
  if (light) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      light = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, light, submessage_arena);
    }
    
  } else {
    
  }
  light_ = light;
  // @@protoc_insertion_point(field_set_allocated:ProtobufControl.light)
}

// .ProtobufControl.Vibro vibro = 4;
inline bool ProtobufControl::has_vibro() const {
  return this != internal_default_instance() && vibro_ != nullptr;
}
inline void ProtobufControl::clear_vibro() {
  if (GetArenaNoVirtual() == nullptr && vibro_ != nullptr) {
    delete vibro_;
  }
  vibro_ = nullptr;
}
inline const ::ProtobufControl_Vibro& ProtobufControl::vibro() const {
  const ::ProtobufControl_Vibro* p = vibro_;
  // @@protoc_insertion_point(field_get:ProtobufControl.vibro)
  return p != nullptr ? *p : *reinterpret_cast<const ::ProtobufControl_Vibro*>(
      &::_ProtobufControl_Vibro_default_instance_);
}
inline ::ProtobufControl_Vibro* ProtobufControl::release_vibro() {
  // @@protoc_insertion_point(field_release:ProtobufControl.vibro)
  
  ::ProtobufControl_Vibro* temp = vibro_;
  vibro_ = nullptr;
  return temp;
}
inline ::ProtobufControl_Vibro* ProtobufControl::mutable_vibro() {
  
  if (vibro_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtobufControl_Vibro>(GetArenaNoVirtual());
    vibro_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufControl.vibro)
  return vibro_;
}
inline void ProtobufControl::set_allocated_vibro(::ProtobufControl_Vibro* vibro) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vibro_;
  }
  if (vibro) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vibro = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vibro, submessage_arena);
    }
    
  } else {
    
  }
  vibro_ = vibro;
  // @@protoc_insertion_point(field_set_allocated:ProtobufControl.vibro)
}

// .ProtobufControl.System system = 5;
inline bool ProtobufControl::has_system() const {
  return this != internal_default_instance() && system_ != nullptr;
}
inline void ProtobufControl::clear_system() {
  if (GetArenaNoVirtual() == nullptr && system_ != nullptr) {
    delete system_;
  }
  system_ = nullptr;
}
inline const ::ProtobufControl_System& ProtobufControl::system() const {
  const ::ProtobufControl_System* p = system_;
  // @@protoc_insertion_point(field_get:ProtobufControl.system)
  return p != nullptr ? *p : *reinterpret_cast<const ::ProtobufControl_System*>(
      &::_ProtobufControl_System_default_instance_);
}
inline ::ProtobufControl_System* ProtobufControl::release_system() {
  // @@protoc_insertion_point(field_release:ProtobufControl.system)
  
  ::ProtobufControl_System* temp = system_;
  system_ = nullptr;
  return temp;
}
inline ::ProtobufControl_System* ProtobufControl::mutable_system() {
  
  if (system_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtobufControl_System>(GetArenaNoVirtual());
    system_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufControl.system)
  return system_;
}
inline void ProtobufControl::set_allocated_system(::ProtobufControl_System* system) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete system_;
  }
  if (system) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      system = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, system, submessage_arena);
    }
    
  } else {
    
  }
  system_ = system;
  // @@protoc_insertion_point(field_set_allocated:ProtobufControl.system)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_control_2eproto
