// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors.proto

#ifndef PROTOBUF_INCLUDED_sensors_2eproto
#define PROTOBUF_INCLUDED_sensors_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensors_2eproto 

namespace protobuf_sensors_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensors_2eproto
class ProtobufSensors;
class ProtobufSensorsDefaultTypeInternal;
extern ProtobufSensorsDefaultTypeInternal _ProtobufSensors_default_instance_;
class ProtobufSensors_Accelerometer;
class ProtobufSensors_AccelerometerDefaultTypeInternal;
extern ProtobufSensors_AccelerometerDefaultTypeInternal _ProtobufSensors_Accelerometer_default_instance_;
class ProtobufSensors_Gyroscope;
class ProtobufSensors_GyroscopeDefaultTypeInternal;
extern ProtobufSensors_GyroscopeDefaultTypeInternal _ProtobufSensors_Gyroscope_default_instance_;
class ProtobufSensors_Misc;
class ProtobufSensors_MiscDefaultTypeInternal;
extern ProtobufSensors_MiscDefaultTypeInternal _ProtobufSensors_Misc_default_instance_;
class ProtobufSensors_MotorEncoders;
class ProtobufSensors_MotorEncodersDefaultTypeInternal;
extern ProtobufSensors_MotorEncodersDefaultTypeInternal _ProtobufSensors_MotorEncoders_default_instance_;
class ProtobufSensors_Temperature;
class ProtobufSensors_TemperatureDefaultTypeInternal;
extern ProtobufSensors_TemperatureDefaultTypeInternal _ProtobufSensors_Temperature_default_instance_;
namespace google {
namespace protobuf {
template<> ::ProtobufSensors* Arena::CreateMaybeMessage<::ProtobufSensors>(Arena*);
template<> ::ProtobufSensors_Accelerometer* Arena::CreateMaybeMessage<::ProtobufSensors_Accelerometer>(Arena*);
template<> ::ProtobufSensors_Gyroscope* Arena::CreateMaybeMessage<::ProtobufSensors_Gyroscope>(Arena*);
template<> ::ProtobufSensors_Misc* Arena::CreateMaybeMessage<::ProtobufSensors_Misc>(Arena*);
template<> ::ProtobufSensors_MotorEncoders* Arena::CreateMaybeMessage<::ProtobufSensors_MotorEncoders>(Arena*);
template<> ::ProtobufSensors_Temperature* Arena::CreateMaybeMessage<::ProtobufSensors_Temperature>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class ProtobufSensors_Accelerometer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufSensors.Accelerometer) */ {
 public:
  ProtobufSensors_Accelerometer();
  virtual ~ProtobufSensors_Accelerometer();

  ProtobufSensors_Accelerometer(const ProtobufSensors_Accelerometer& from);

  inline ProtobufSensors_Accelerometer& operator=(const ProtobufSensors_Accelerometer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufSensors_Accelerometer(ProtobufSensors_Accelerometer&& from) noexcept
    : ProtobufSensors_Accelerometer() {
    *this = ::std::move(from);
  }

  inline ProtobufSensors_Accelerometer& operator=(ProtobufSensors_Accelerometer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtobufSensors_Accelerometer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufSensors_Accelerometer* internal_default_instance() {
    return reinterpret_cast<const ProtobufSensors_Accelerometer*>(
               &_ProtobufSensors_Accelerometer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ProtobufSensors_Accelerometer* other);
  friend void swap(ProtobufSensors_Accelerometer& a, ProtobufSensors_Accelerometer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufSensors_Accelerometer* New() const final {
    return CreateMaybeMessage<ProtobufSensors_Accelerometer>(NULL);
  }

  ProtobufSensors_Accelerometer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufSensors_Accelerometer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufSensors_Accelerometer& from);
  void MergeFrom(const ProtobufSensors_Accelerometer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufSensors_Accelerometer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:ProtobufSensors.Accelerometer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtobufSensors_Gyroscope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufSensors.Gyroscope) */ {
 public:
  ProtobufSensors_Gyroscope();
  virtual ~ProtobufSensors_Gyroscope();

  ProtobufSensors_Gyroscope(const ProtobufSensors_Gyroscope& from);

  inline ProtobufSensors_Gyroscope& operator=(const ProtobufSensors_Gyroscope& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufSensors_Gyroscope(ProtobufSensors_Gyroscope&& from) noexcept
    : ProtobufSensors_Gyroscope() {
    *this = ::std::move(from);
  }

  inline ProtobufSensors_Gyroscope& operator=(ProtobufSensors_Gyroscope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtobufSensors_Gyroscope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufSensors_Gyroscope* internal_default_instance() {
    return reinterpret_cast<const ProtobufSensors_Gyroscope*>(
               &_ProtobufSensors_Gyroscope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ProtobufSensors_Gyroscope* other);
  friend void swap(ProtobufSensors_Gyroscope& a, ProtobufSensors_Gyroscope& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufSensors_Gyroscope* New() const final {
    return CreateMaybeMessage<ProtobufSensors_Gyroscope>(NULL);
  }

  ProtobufSensors_Gyroscope* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufSensors_Gyroscope>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufSensors_Gyroscope& from);
  void MergeFrom(const ProtobufSensors_Gyroscope& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufSensors_Gyroscope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:ProtobufSensors.Gyroscope)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtobufSensors_MotorEncoders : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufSensors.MotorEncoders) */ {
 public:
  ProtobufSensors_MotorEncoders();
  virtual ~ProtobufSensors_MotorEncoders();

  ProtobufSensors_MotorEncoders(const ProtobufSensors_MotorEncoders& from);

  inline ProtobufSensors_MotorEncoders& operator=(const ProtobufSensors_MotorEncoders& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufSensors_MotorEncoders(ProtobufSensors_MotorEncoders&& from) noexcept
    : ProtobufSensors_MotorEncoders() {
    *this = ::std::move(from);
  }

  inline ProtobufSensors_MotorEncoders& operator=(ProtobufSensors_MotorEncoders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtobufSensors_MotorEncoders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufSensors_MotorEncoders* internal_default_instance() {
    return reinterpret_cast<const ProtobufSensors_MotorEncoders*>(
               &_ProtobufSensors_MotorEncoders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProtobufSensors_MotorEncoders* other);
  friend void swap(ProtobufSensors_MotorEncoders& a, ProtobufSensors_MotorEncoders& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufSensors_MotorEncoders* New() const final {
    return CreateMaybeMessage<ProtobufSensors_MotorEncoders>(NULL);
  }

  ProtobufSensors_MotorEncoders* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufSensors_MotorEncoders>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufSensors_MotorEncoders& from);
  void MergeFrom(const ProtobufSensors_MotorEncoders& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufSensors_MotorEncoders* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 lAngle = 1;
  void clear_langle();
  static const int kLAngleFieldNumber = 1;
  ::google::protobuf::int32 langle() const;
  void set_langle(::google::protobuf::int32 value);

  // int32 rAngle = 2;
  void clear_rangle();
  static const int kRAngleFieldNumber = 2;
  ::google::protobuf::int32 rangle() const;
  void set_rangle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtobufSensors.MotorEncoders)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 langle_;
  ::google::protobuf::int32 rangle_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtobufSensors_Temperature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufSensors.Temperature) */ {
 public:
  ProtobufSensors_Temperature();
  virtual ~ProtobufSensors_Temperature();

  ProtobufSensors_Temperature(const ProtobufSensors_Temperature& from);

  inline ProtobufSensors_Temperature& operator=(const ProtobufSensors_Temperature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufSensors_Temperature(ProtobufSensors_Temperature&& from) noexcept
    : ProtobufSensors_Temperature() {
    *this = ::std::move(from);
  }

  inline ProtobufSensors_Temperature& operator=(ProtobufSensors_Temperature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtobufSensors_Temperature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufSensors_Temperature* internal_default_instance() {
    return reinterpret_cast<const ProtobufSensors_Temperature*>(
               &_ProtobufSensors_Temperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProtobufSensors_Temperature* other);
  friend void swap(ProtobufSensors_Temperature& a, ProtobufSensors_Temperature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufSensors_Temperature* New() const final {
    return CreateMaybeMessage<ProtobufSensors_Temperature>(NULL);
  }

  ProtobufSensors_Temperature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufSensors_Temperature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufSensors_Temperature& from);
  void MergeFrom(const ProtobufSensors_Temperature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufSensors_Temperature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 tempAccelerometer = 1;
  void clear_tempaccelerometer();
  static const int kTempAccelerometerFieldNumber = 1;
  ::google::protobuf::int32 tempaccelerometer() const;
  void set_tempaccelerometer(::google::protobuf::int32 value);

  // int32 tempCPU = 2;
  void clear_tempcpu();
  static const int kTempCPUFieldNumber = 2;
  ::google::protobuf::int32 tempcpu() const;
  void set_tempcpu(::google::protobuf::int32 value);

  // int32 tempPressure = 3;
  void clear_temppressure();
  static const int kTempPressureFieldNumber = 3;
  ::google::protobuf::int32 temppressure() const;
  void set_temppressure(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtobufSensors.Temperature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 tempaccelerometer_;
  ::google::protobuf::int32 tempcpu_;
  ::google::protobuf::int32 temppressure_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtobufSensors_Misc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufSensors.Misc) */ {
 public:
  ProtobufSensors_Misc();
  virtual ~ProtobufSensors_Misc();

  ProtobufSensors_Misc(const ProtobufSensors_Misc& from);

  inline ProtobufSensors_Misc& operator=(const ProtobufSensors_Misc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufSensors_Misc(ProtobufSensors_Misc&& from) noexcept
    : ProtobufSensors_Misc() {
    *this = ::std::move(from);
  }

  inline ProtobufSensors_Misc& operator=(ProtobufSensors_Misc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtobufSensors_Misc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufSensors_Misc* internal_default_instance() {
    return reinterpret_cast<const ProtobufSensors_Misc*>(
               &_ProtobufSensors_Misc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProtobufSensors_Misc* other);
  friend void swap(ProtobufSensors_Misc& a, ProtobufSensors_Misc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufSensors_Misc* New() const final {
    return CreateMaybeMessage<ProtobufSensors_Misc>(NULL);
  }

  ProtobufSensors_Misc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufSensors_Misc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufSensors_Misc& from);
  void MergeFrom(const ProtobufSensors_Misc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufSensors_Misc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 gas = 1;
  void clear_gas();
  static const int kGasFieldNumber = 1;
  ::google::protobuf::int32 gas() const;
  void set_gas(::google::protobuf::int32 value);

  // int32 batteryVoltage = 2;
  void clear_batteryvoltage();
  static const int kBatteryVoltageFieldNumber = 2;
  ::google::protobuf::int32 batteryvoltage() const;
  void set_batteryvoltage(::google::protobuf::int32 value);

  // float pressure = 3;
  void clear_pressure();
  static const int kPressureFieldNumber = 3;
  float pressure() const;
  void set_pressure(float value);

  // @@protoc_insertion_point(class_scope:ProtobufSensors.Misc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 gas_;
  ::google::protobuf::int32 batteryvoltage_;
  float pressure_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensors_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtobufSensors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtobufSensors) */ {
 public:
  ProtobufSensors();
  virtual ~ProtobufSensors();

  ProtobufSensors(const ProtobufSensors& from);

  inline ProtobufSensors& operator=(const ProtobufSensors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtobufSensors(ProtobufSensors&& from) noexcept
    : ProtobufSensors() {
    *this = ::std::move(from);
  }

  inline ProtobufSensors& operator=(ProtobufSensors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtobufSensors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtobufSensors* internal_default_instance() {
    return reinterpret_cast<const ProtobufSensors*>(
               &_ProtobufSensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ProtobufSensors* other);
  friend void swap(ProtobufSensors& a, ProtobufSensors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtobufSensors* New() const final {
    return CreateMaybeMessage<ProtobufSensors>(NULL);
  }

  ProtobufSensors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtobufSensors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtobufSensors& from);
  void MergeFrom(const ProtobufSensors& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtobufSensors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProtobufSensors_Accelerometer Accelerometer;
  typedef ProtobufSensors_Gyroscope Gyroscope;
  typedef ProtobufSensors_MotorEncoders MotorEncoders;
  typedef ProtobufSensors_Temperature Temperature;
  typedef ProtobufSensors_Misc Misc;

  // accessors -------------------------------------------------------

  // .ProtobufSensors.Accelerometer accelerometer = 1;
  bool has_accelerometer() const;
  void clear_accelerometer();
  static const int kAccelerometerFieldNumber = 1;
  private:
  const ::ProtobufSensors_Accelerometer& _internal_accelerometer() const;
  public:
  const ::ProtobufSensors_Accelerometer& accelerometer() const;
  ::ProtobufSensors_Accelerometer* release_accelerometer();
  ::ProtobufSensors_Accelerometer* mutable_accelerometer();
  void set_allocated_accelerometer(::ProtobufSensors_Accelerometer* accelerometer);

  // .ProtobufSensors.Gyroscope gyroscope = 2;
  bool has_gyroscope() const;
  void clear_gyroscope();
  static const int kGyroscopeFieldNumber = 2;
  private:
  const ::ProtobufSensors_Gyroscope& _internal_gyroscope() const;
  public:
  const ::ProtobufSensors_Gyroscope& gyroscope() const;
  ::ProtobufSensors_Gyroscope* release_gyroscope();
  ::ProtobufSensors_Gyroscope* mutable_gyroscope();
  void set_allocated_gyroscope(::ProtobufSensors_Gyroscope* gyroscope);

  // .ProtobufSensors.MotorEncoders motorEncoders = 3;
  bool has_motorencoders() const;
  void clear_motorencoders();
  static const int kMotorEncodersFieldNumber = 3;
  private:
  const ::ProtobufSensors_MotorEncoders& _internal_motorencoders() const;
  public:
  const ::ProtobufSensors_MotorEncoders& motorencoders() const;
  ::ProtobufSensors_MotorEncoders* release_motorencoders();
  ::ProtobufSensors_MotorEncoders* mutable_motorencoders();
  void set_allocated_motorencoders(::ProtobufSensors_MotorEncoders* motorencoders);

  // .ProtobufSensors.Temperature temperature = 4;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 4;
  private:
  const ::ProtobufSensors_Temperature& _internal_temperature() const;
  public:
  const ::ProtobufSensors_Temperature& temperature() const;
  ::ProtobufSensors_Temperature* release_temperature();
  ::ProtobufSensors_Temperature* mutable_temperature();
  void set_allocated_temperature(::ProtobufSensors_Temperature* temperature);

  // .ProtobufSensors.Misc misc = 5;
  bool has_misc() const;
  void clear_misc();
  static const int kMiscFieldNumber = 5;
  private:
  const ::ProtobufSensors_Misc& _internal_misc() const;
  public:
  const ::ProtobufSensors_Misc& misc() const;
  ::ProtobufSensors_Misc* release_misc();
  ::ProtobufSensors_Misc* mutable_misc();
  void set_allocated_misc(::ProtobufSensors_Misc* misc);

  // @@protoc_insertion_point(class_scope:ProtobufSensors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ProtobufSensors_Accelerometer* accelerometer_;
  ::ProtobufSensors_Gyroscope* gyroscope_;
  ::ProtobufSensors_MotorEncoders* motorencoders_;
  ::ProtobufSensors_Temperature* temperature_;
  ::ProtobufSensors_Misc* misc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensors_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtobufSensors_Accelerometer

// float x = 1;
inline void ProtobufSensors_Accelerometer::clear_x() {
  x_ = 0;
}
inline float ProtobufSensors_Accelerometer::x() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Accelerometer.x)
  return x_;
}
inline void ProtobufSensors_Accelerometer::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Accelerometer.x)
}

// float y = 2;
inline void ProtobufSensors_Accelerometer::clear_y() {
  y_ = 0;
}
inline float ProtobufSensors_Accelerometer::y() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Accelerometer.y)
  return y_;
}
inline void ProtobufSensors_Accelerometer::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Accelerometer.y)
}

// float z = 3;
inline void ProtobufSensors_Accelerometer::clear_z() {
  z_ = 0;
}
inline float ProtobufSensors_Accelerometer::z() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Accelerometer.z)
  return z_;
}
inline void ProtobufSensors_Accelerometer::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Accelerometer.z)
}

// -------------------------------------------------------------------

// ProtobufSensors_Gyroscope

// float x = 1;
inline void ProtobufSensors_Gyroscope::clear_x() {
  x_ = 0;
}
inline float ProtobufSensors_Gyroscope::x() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Gyroscope.x)
  return x_;
}
inline void ProtobufSensors_Gyroscope::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Gyroscope.x)
}

// float y = 2;
inline void ProtobufSensors_Gyroscope::clear_y() {
  y_ = 0;
}
inline float ProtobufSensors_Gyroscope::y() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Gyroscope.y)
  return y_;
}
inline void ProtobufSensors_Gyroscope::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Gyroscope.y)
}

// float z = 3;
inline void ProtobufSensors_Gyroscope::clear_z() {
  z_ = 0;
}
inline float ProtobufSensors_Gyroscope::z() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Gyroscope.z)
  return z_;
}
inline void ProtobufSensors_Gyroscope::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Gyroscope.z)
}

// -------------------------------------------------------------------

// ProtobufSensors_MotorEncoders

// int32 lAngle = 1;
inline void ProtobufSensors_MotorEncoders::clear_langle() {
  langle_ = 0;
}
inline ::google::protobuf::int32 ProtobufSensors_MotorEncoders::langle() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.MotorEncoders.lAngle)
  return langle_;
}
inline void ProtobufSensors_MotorEncoders::set_langle(::google::protobuf::int32 value) {
  
  langle_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.MotorEncoders.lAngle)
}

// int32 rAngle = 2;
inline void ProtobufSensors_MotorEncoders::clear_rangle() {
  rangle_ = 0;
}
inline ::google::protobuf::int32 ProtobufSensors_MotorEncoders::rangle() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.MotorEncoders.rAngle)
  return rangle_;
}
inline void ProtobufSensors_MotorEncoders::set_rangle(::google::protobuf::int32 value) {
  
  rangle_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.MotorEncoders.rAngle)
}

// -------------------------------------------------------------------

// ProtobufSensors_Temperature

// int32 tempAccelerometer = 1;
inline void ProtobufSensors_Temperature::clear_tempaccelerometer() {
  tempaccelerometer_ = 0;
}
inline ::google::protobuf::int32 ProtobufSensors_Temperature::tempaccelerometer() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Temperature.tempAccelerometer)
  return tempaccelerometer_;
}
inline void ProtobufSensors_Temperature::set_tempaccelerometer(::google::protobuf::int32 value) {
  
  tempaccelerometer_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Temperature.tempAccelerometer)
}

// int32 tempCPU = 2;
inline void ProtobufSensors_Temperature::clear_tempcpu() {
  tempcpu_ = 0;
}
inline ::google::protobuf::int32 ProtobufSensors_Temperature::tempcpu() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Temperature.tempCPU)
  return tempcpu_;
}
inline void ProtobufSensors_Temperature::set_tempcpu(::google::protobuf::int32 value) {
  
  tempcpu_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Temperature.tempCPU)
}

// int32 tempPressure = 3;
inline void ProtobufSensors_Temperature::clear_temppressure() {
  temppressure_ = 0;
}
inline ::google::protobuf::int32 ProtobufSensors_Temperature::temppressure() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Temperature.tempPressure)
  return temppressure_;
}
inline void ProtobufSensors_Temperature::set_temppressure(::google::protobuf::int32 value) {
  
  temppressure_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Temperature.tempPressure)
}

// -------------------------------------------------------------------

// ProtobufSensors_Misc

// int32 gas = 1;
inline void ProtobufSensors_Misc::clear_gas() {
  gas_ = 0;
}
inline ::google::protobuf::int32 ProtobufSensors_Misc::gas() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Misc.gas)
  return gas_;
}
inline void ProtobufSensors_Misc::set_gas(::google::protobuf::int32 value) {
  
  gas_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Misc.gas)
}

// int32 batteryVoltage = 2;
inline void ProtobufSensors_Misc::clear_batteryvoltage() {
  batteryvoltage_ = 0;
}
inline ::google::protobuf::int32 ProtobufSensors_Misc::batteryvoltage() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Misc.batteryVoltage)
  return batteryvoltage_;
}
inline void ProtobufSensors_Misc::set_batteryvoltage(::google::protobuf::int32 value) {
  
  batteryvoltage_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Misc.batteryVoltage)
}

// float pressure = 3;
inline void ProtobufSensors_Misc::clear_pressure() {
  pressure_ = 0;
}
inline float ProtobufSensors_Misc::pressure() const {
  // @@protoc_insertion_point(field_get:ProtobufSensors.Misc.pressure)
  return pressure_;
}
inline void ProtobufSensors_Misc::set_pressure(float value) {
  
  pressure_ = value;
  // @@protoc_insertion_point(field_set:ProtobufSensors.Misc.pressure)
}

// -------------------------------------------------------------------

// ProtobufSensors

// .ProtobufSensors.Accelerometer accelerometer = 1;
inline bool ProtobufSensors::has_accelerometer() const {
  return this != internal_default_instance() && accelerometer_ != NULL;
}
inline void ProtobufSensors::clear_accelerometer() {
  if (GetArenaNoVirtual() == NULL && accelerometer_ != NULL) {
    delete accelerometer_;
  }
  accelerometer_ = NULL;
}
inline const ::ProtobufSensors_Accelerometer& ProtobufSensors::_internal_accelerometer() const {
  return *accelerometer_;
}
inline const ::ProtobufSensors_Accelerometer& ProtobufSensors::accelerometer() const {
  const ::ProtobufSensors_Accelerometer* p = accelerometer_;
  // @@protoc_insertion_point(field_get:ProtobufSensors.accelerometer)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtobufSensors_Accelerometer*>(
      &::_ProtobufSensors_Accelerometer_default_instance_);
}
inline ::ProtobufSensors_Accelerometer* ProtobufSensors::release_accelerometer() {
  // @@protoc_insertion_point(field_release:ProtobufSensors.accelerometer)
  
  ::ProtobufSensors_Accelerometer* temp = accelerometer_;
  accelerometer_ = NULL;
  return temp;
}
inline ::ProtobufSensors_Accelerometer* ProtobufSensors::mutable_accelerometer() {
  
  if (accelerometer_ == NULL) {
    auto* p = CreateMaybeMessage<::ProtobufSensors_Accelerometer>(GetArenaNoVirtual());
    accelerometer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufSensors.accelerometer)
  return accelerometer_;
}
inline void ProtobufSensors::set_allocated_accelerometer(::ProtobufSensors_Accelerometer* accelerometer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete accelerometer_;
  }
  if (accelerometer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      accelerometer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accelerometer, submessage_arena);
    }
    
  } else {
    
  }
  accelerometer_ = accelerometer;
  // @@protoc_insertion_point(field_set_allocated:ProtobufSensors.accelerometer)
}

// .ProtobufSensors.Gyroscope gyroscope = 2;
inline bool ProtobufSensors::has_gyroscope() const {
  return this != internal_default_instance() && gyroscope_ != NULL;
}
inline void ProtobufSensors::clear_gyroscope() {
  if (GetArenaNoVirtual() == NULL && gyroscope_ != NULL) {
    delete gyroscope_;
  }
  gyroscope_ = NULL;
}
inline const ::ProtobufSensors_Gyroscope& ProtobufSensors::_internal_gyroscope() const {
  return *gyroscope_;
}
inline const ::ProtobufSensors_Gyroscope& ProtobufSensors::gyroscope() const {
  const ::ProtobufSensors_Gyroscope* p = gyroscope_;
  // @@protoc_insertion_point(field_get:ProtobufSensors.gyroscope)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtobufSensors_Gyroscope*>(
      &::_ProtobufSensors_Gyroscope_default_instance_);
}
inline ::ProtobufSensors_Gyroscope* ProtobufSensors::release_gyroscope() {
  // @@protoc_insertion_point(field_release:ProtobufSensors.gyroscope)
  
  ::ProtobufSensors_Gyroscope* temp = gyroscope_;
  gyroscope_ = NULL;
  return temp;
}
inline ::ProtobufSensors_Gyroscope* ProtobufSensors::mutable_gyroscope() {
  
  if (gyroscope_ == NULL) {
    auto* p = CreateMaybeMessage<::ProtobufSensors_Gyroscope>(GetArenaNoVirtual());
    gyroscope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufSensors.gyroscope)
  return gyroscope_;
}
inline void ProtobufSensors::set_allocated_gyroscope(::ProtobufSensors_Gyroscope* gyroscope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gyroscope_;
  }
  if (gyroscope) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gyroscope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gyroscope, submessage_arena);
    }
    
  } else {
    
  }
  gyroscope_ = gyroscope;
  // @@protoc_insertion_point(field_set_allocated:ProtobufSensors.gyroscope)
}

// .ProtobufSensors.MotorEncoders motorEncoders = 3;
inline bool ProtobufSensors::has_motorencoders() const {
  return this != internal_default_instance() && motorencoders_ != NULL;
}
inline void ProtobufSensors::clear_motorencoders() {
  if (GetArenaNoVirtual() == NULL && motorencoders_ != NULL) {
    delete motorencoders_;
  }
  motorencoders_ = NULL;
}
inline const ::ProtobufSensors_MotorEncoders& ProtobufSensors::_internal_motorencoders() const {
  return *motorencoders_;
}
inline const ::ProtobufSensors_MotorEncoders& ProtobufSensors::motorencoders() const {
  const ::ProtobufSensors_MotorEncoders* p = motorencoders_;
  // @@protoc_insertion_point(field_get:ProtobufSensors.motorEncoders)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtobufSensors_MotorEncoders*>(
      &::_ProtobufSensors_MotorEncoders_default_instance_);
}
inline ::ProtobufSensors_MotorEncoders* ProtobufSensors::release_motorencoders() {
  // @@protoc_insertion_point(field_release:ProtobufSensors.motorEncoders)
  
  ::ProtobufSensors_MotorEncoders* temp = motorencoders_;
  motorencoders_ = NULL;
  return temp;
}
inline ::ProtobufSensors_MotorEncoders* ProtobufSensors::mutable_motorencoders() {
  
  if (motorencoders_ == NULL) {
    auto* p = CreateMaybeMessage<::ProtobufSensors_MotorEncoders>(GetArenaNoVirtual());
    motorencoders_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufSensors.motorEncoders)
  return motorencoders_;
}
inline void ProtobufSensors::set_allocated_motorencoders(::ProtobufSensors_MotorEncoders* motorencoders) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete motorencoders_;
  }
  if (motorencoders) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      motorencoders = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motorencoders, submessage_arena);
    }
    
  } else {
    
  }
  motorencoders_ = motorencoders;
  // @@protoc_insertion_point(field_set_allocated:ProtobufSensors.motorEncoders)
}

// .ProtobufSensors.Temperature temperature = 4;
inline bool ProtobufSensors::has_temperature() const {
  return this != internal_default_instance() && temperature_ != NULL;
}
inline void ProtobufSensors::clear_temperature() {
  if (GetArenaNoVirtual() == NULL && temperature_ != NULL) {
    delete temperature_;
  }
  temperature_ = NULL;
}
inline const ::ProtobufSensors_Temperature& ProtobufSensors::_internal_temperature() const {
  return *temperature_;
}
inline const ::ProtobufSensors_Temperature& ProtobufSensors::temperature() const {
  const ::ProtobufSensors_Temperature* p = temperature_;
  // @@protoc_insertion_point(field_get:ProtobufSensors.temperature)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtobufSensors_Temperature*>(
      &::_ProtobufSensors_Temperature_default_instance_);
}
inline ::ProtobufSensors_Temperature* ProtobufSensors::release_temperature() {
  // @@protoc_insertion_point(field_release:ProtobufSensors.temperature)
  
  ::ProtobufSensors_Temperature* temp = temperature_;
  temperature_ = NULL;
  return temp;
}
inline ::ProtobufSensors_Temperature* ProtobufSensors::mutable_temperature() {
  
  if (temperature_ == NULL) {
    auto* p = CreateMaybeMessage<::ProtobufSensors_Temperature>(GetArenaNoVirtual());
    temperature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufSensors.temperature)
  return temperature_;
}
inline void ProtobufSensors::set_allocated_temperature(::ProtobufSensors_Temperature* temperature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete temperature_;
  }
  if (temperature) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      temperature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, temperature, submessage_arena);
    }
    
  } else {
    
  }
  temperature_ = temperature;
  // @@protoc_insertion_point(field_set_allocated:ProtobufSensors.temperature)
}

// .ProtobufSensors.Misc misc = 5;
inline bool ProtobufSensors::has_misc() const {
  return this != internal_default_instance() && misc_ != NULL;
}
inline void ProtobufSensors::clear_misc() {
  if (GetArenaNoVirtual() == NULL && misc_ != NULL) {
    delete misc_;
  }
  misc_ = NULL;
}
inline const ::ProtobufSensors_Misc& ProtobufSensors::_internal_misc() const {
  return *misc_;
}
inline const ::ProtobufSensors_Misc& ProtobufSensors::misc() const {
  const ::ProtobufSensors_Misc* p = misc_;
  // @@protoc_insertion_point(field_get:ProtobufSensors.misc)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtobufSensors_Misc*>(
      &::_ProtobufSensors_Misc_default_instance_);
}
inline ::ProtobufSensors_Misc* ProtobufSensors::release_misc() {
  // @@protoc_insertion_point(field_release:ProtobufSensors.misc)
  
  ::ProtobufSensors_Misc* temp = misc_;
  misc_ = NULL;
  return temp;
}
inline ::ProtobufSensors_Misc* ProtobufSensors::mutable_misc() {
  
  if (misc_ == NULL) {
    auto* p = CreateMaybeMessage<::ProtobufSensors_Misc>(GetArenaNoVirtual());
    misc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ProtobufSensors.misc)
  return misc_;
}
inline void ProtobufSensors::set_allocated_misc(::ProtobufSensors_Misc* misc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete misc_;
  }
  if (misc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      misc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, misc, submessage_arena);
    }
    
  } else {
    
  }
  misc_ = misc;
  // @@protoc_insertion_point(field_set_allocated:ProtobufSensors.misc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensors_2eproto
